import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { databaseService } from '../../services/DatabaseService';
import { firebaseService } from '../../services/FirebaseService';
import { handleOfflineDelete } from '../../utils/offlineDeleteHandler';

// Types locaux pour √©viter les conflits
interface Product {
  id: string;
  name: string;
  description?: string;
  sku: string;
  barcode?: string;
  category_id?: string;
  price_buy: number;
  price_sell: number;
  margin: number;
  unit: string;
  images?: string[];
  is_active: boolean;
  created_at: any;
  updated_at: any;
  sync_status: 'synced' | 'pending' | 'error';
}

interface ProductState {
  products: Product[];
  loading: boolean;
  error: string | null;
  lastSync: string | null;
  offlineMode: boolean;
  searchQuery: string;
  selectedCategory: string;
  sortBy: 'name' | 'price' | 'created_at';
  sortOrder: 'asc' | 'desc';
}

const initialState: ProductState = {
  products: [],
  loading: false,
  error: null,
  lastSync: null,
  offlineMode: false,
  searchQuery: '',
  selectedCategory: 'all',
  sortBy: 'name',
  sortOrder: 'asc',
};

// Thunks pour les op√©rations async
export const fetchProducts = createAsyncThunk(
  'products/fetchProducts',
  async (_, { getState, dispatch }) => {
    const state = getState() as { network: { isConnected: boolean } };
    
    try {
      // OPTIMISATION : Toujours charger local d'abord pour un affichage rapide
      console.log('‚ö° Chargement rapide des produits locaux...');
      const localProducts = await databaseService.getAll('products');
      
      // Toujours retourner les produits locaux imm√©diatement
      console.log(`‚ö° ${localProducts.length} produits locaux charg√©s instantan√©ment`);
      dispatch(setOfflineMode(true));
      
      // En arri√®re-plan, essayer de synchroniser avec Firebase si en ligne
      if (state.network.isConnected) {
        console.log('üîÑ Synchronisation en arri√®re-plan...');
        // Ne pas attendre Firebase, laisser tourner en arri√®re-plan
        firebaseService.getProducts().then(firebaseProducts => {
          if (firebaseProducts.length > 0) {
            console.log(`üîÑ ${firebaseProducts.length} produits Firebase r√©cup√©r√©s en arri√®re-plan`);
            dispatch(setOfflineMode(false));
            dispatch(setLastSync(new Date().toISOString()));
            // Optionnel: mettre √† jour les produits si n√©cessaire
          }
        }).catch(error => {
          // Masquer les erreurs de timeout Firebase
          if (error instanceof Error && error.message.includes('Timeout Firebase')) {
            console.log('‚ö†Ô∏è Firebase timeout (normal), utilisation des donn√©es locales');
          } else {
            console.log('‚ö†Ô∏è Sync Firebase √©chou√©e en arri√®re-plan, utilisation des donn√©es locales');
          }
        });
      }
      
      return localProducts;
      
      // Si pas de donn√©es locales, essayer Firebase
      if (state.network.isConnected) {
        try {
          const products = await firebaseService.getProducts();
          dispatch(setLastSync(new Date().toISOString()));
          dispatch(setOfflineMode(false));
          return products;
        } catch (error) {
          console.error('Erreur r√©cup√©ration Firebase:', error);
          dispatch(setOfflineMode(true));
          return [];
        }
      }
      
      return [];
    } catch (error) {
      console.error('Erreur fetchProducts:', error);
      throw error;
    }
  }
);

export const createProduct = createAsyncThunk(
  'products/createProduct',
  async (productData: Omit<Product, 'id' | 'created_at' | 'updated_at' | 'sync_status'>, { dispatch, getState }) => {
    console.log('üöÄ [REDUX DEBUG] D√©but createProduct');
    console.log('üöÄ [REDUX DEBUG] ProductData re√ßu:', productData);
    
    try {
      const state = getState() as { network: { isConnected: boolean } };
      console.log('üåê [REDUX DEBUG] √âtat r√©seau:', state.network.isConnected);
      
      // TOUJOURS cr√©er localement d'abord pour √©viter les blocages
      console.log('üì± [REDUX DEBUG] Cr√©ation locale prioritaire');
      const newProduct: Omit<Product, 'id'> = {
        ...productData,
        created_at: new Date().toISOString() as any,
        updated_at: new Date().toISOString() as any,
        sync_status: 'pending',
      };

      console.log('üîÑ [REDUX DEBUG] Appel databaseService.insert');
      const id = await databaseService.insert('products', newProduct);
      console.log('‚úÖ [REDUX DEBUG] databaseService.insert termin√©, ID:', id);
      
      const createdProduct = { ...newProduct, id };
          console.log('‚úÖ [REDUX DEBUG] Produit cr√©√© localement:', id);
          
          // En arri√®re-plan, essayer de synchroniser avec Firebase
          if (state.network.isConnected) {
            console.log('üîÑ [REDUX DEBUG] Tentative sync Firebase en arri√®re-plan');
            firebaseService.createProduct(productData).then(firebaseId => {
              console.log('‚úÖ [REDUX DEBUG] Sync Firebase r√©ussie, ID:', firebaseId);
              // Mettre √† jour le statut de sync
              databaseService.update('products', id, { sync_status: 'synced' });
            }).catch(error => {
              // Masquer les erreurs de timeout Firebase et mode offline
              if (error instanceof Error && error.message.includes('Timeout Firebase')) {
                console.log('‚ö†Ô∏è [REDUX DEBUG] Firebase timeout (normal), produit cr√©√© localement');
                // Ajouter √† la queue de sync pour tentative ult√©rieure
                console.log('üîÑ [REDUX DEBUG] Ajout √† la queue de synchronisation');
                databaseService.insert('sync_queue', {
                  table_name: 'products',
                  record_id: id,
                  operation: 'create',
                  data: JSON.stringify(productData),
                  priority: 1,
                  status: 'pending',
                  retry_count: 0,
                  created_at: new Date().toISOString(),
                });
              } else if (error instanceof Error && error.message.includes('Mode offline')) {
                console.log('üì± [REDUX DEBUG] Mode offline - produit cr√©√© localement (normal)');
                // Ajouter √† la queue de sync pour quand on repassera en ligne
                console.log('üîÑ [REDUX DEBUG] Ajout √† la queue de synchronisation pour mode offline');
                databaseService.insert('sync_queue', {
                  table_name: 'products',
                  record_id: id,
                  operation: 'create',
                  data: JSON.stringify(productData),
                  priority: 1,
                  status: 'pending',
                  retry_count: 0,
                  created_at: new Date().toISOString(),
                });
              } else {
                console.log('‚ö†Ô∏è [REDUX DEBUG] Sync Firebase √©chou√©e:', error.message);
                // Ajouter √† la queue de sync pour tentative ult√©rieure
                console.log('üîÑ [REDUX DEBUG] Ajout √† la queue de synchronisation');
                databaseService.insert('sync_queue', {
                  table_name: 'products',
                  record_id: id,
                  operation: 'create',
                  data: JSON.stringify(productData),
                  priority: 1,
                  status: 'pending',
                  retry_count: 0,
                  created_at: new Date().toISOString(),
                });
              }
            });
          } else {
            // Mode offline - ajouter directement √† la queue de sync
            console.log('üì± [REDUX DEBUG] Mode offline - ajout √† la queue de synchronisation');
            databaseService.insert('sync_queue', {
              table_name: 'products',
              record_id: id,
              operation: 'create',
              data: JSON.stringify(productData),
              priority: 1,
              status: 'pending',
              retry_count: 0,
              created_at: new Date().toISOString(),
            });
          }
      
      return createdProduct;
    } catch (error) {
      console.error('‚ùå [REDUX DEBUG] Erreur createProduct:', error);
      console.error('‚ùå [REDUX DEBUG] Stack trace:', error.stack);
      throw error;
    }
  }
);

export const updateProduct = createAsyncThunk(
  'products/updateProduct',
  async ({ id, productData }: { id: string; productData: Partial<Product> }, { dispatch, getState }) => {
    const state = getState() as { network: { isConnected: boolean } };
    
    try {
      console.log('üîÑ [REDUX DEBUG] D√©but updateProduct');
      console.log('üîÑ [REDUX DEBUG] ID:', id);
      console.log('üîÑ [REDUX DEBUG] ProductData:', productData);

      // Mettre √† jour localement en priorit√©
      const updateData = {
        ...productData,
        updated_at: new Date().toISOString(),
        sync_status: 'pending' as const,
      };

      console.log('üîÑ [REDUX DEBUG] Mise √† jour locale...');
      await databaseService.update('products', id, updateData);
      
      // R√©cup√©rer le produit mis √† jour
      const products = await databaseService.getAll('products');
      const updatedProduct = products.find((p: any) => p.id === id);
      
      if (!updatedProduct) {
        throw new Error('Produit non trouv√© apr√®s mise √† jour');
      }

      console.log('‚úÖ [REDUX DEBUG] Produit mis √† jour localement:', id);
      
      // En arri√®re-plan, essayer de synchroniser avec Firebase
      if (state.network.isConnected) {
        console.log('üîÑ [REDUX DEBUG] Tentative sync Firebase en arri√®re-plan');
        firebaseService.updateProduct(id, productData).then(() => {
          console.log('‚úÖ [REDUX DEBUG] Sync Firebase r√©ussie');
          // Mettre √† jour le statut de sync
          databaseService.update('products', id, { sync_status: 'synced' });
        }).catch(error => {
          // Masquer les erreurs de timeout Firebase et mode offline
          if (error instanceof Error && error.message.includes('Timeout Firebase')) {
            console.log('‚ö†Ô∏è [REDUX DEBUG] Firebase timeout (normal), produit mis √† jour localement');
            // Ajouter √† la queue de sync pour tentative ult√©rieure
            databaseService.insert('sync_queue', {
              table_name: 'products',
              record_id: id,
              operation: 'update',
              data: JSON.stringify(productData),
              priority: 1,
              status: 'pending',
              retry_count: 0,
              created_at: new Date().toISOString(),
            });
          } else if (error instanceof Error && error.message.includes('Mode offline')) {
            console.log('üì± [REDUX DEBUG] Mode offline - produit mis √† jour localement (normal)');
            // Ajouter √† la queue de sync pour quand on repassera en ligne
            databaseService.insert('sync_queue', {
              table_name: 'products',
              record_id: id,
              operation: 'update',
              data: JSON.stringify(productData),
              priority: 1,
              status: 'pending',
              retry_count: 0,
              created_at: new Date().toISOString(),
            });
          } else {
            console.log('‚ö†Ô∏è [REDUX DEBUG] Sync Firebase √©chou√©e:', error.message);
            // Ajouter √† la queue de sync pour tentative ult√©rieure
            databaseService.insert('sync_queue', {
              table_name: 'products',
              record_id: id,
              operation: 'update',
              data: JSON.stringify(productData),
              priority: 1,
              status: 'pending',
              retry_count: 0,
              created_at: new Date().toISOString(),
            });
          }
        });
      } else {
        // Mode offline - ajouter directement √† la queue de sync
        console.log('üì± [REDUX DEBUG] Mode offline - ajout √† la queue de synchronisation');
        databaseService.insert('sync_queue', {
          table_name: 'products',
          record_id: id,
          operation: 'update',
          data: JSON.stringify(productData),
          priority: 1,
          status: 'pending',
          retry_count: 0,
          created_at: new Date().toISOString(),
        });
      }
      
      return updatedProduct;
    } catch (error) {
      console.error('‚ùå [REDUX DEBUG] Erreur updateProduct:', error);
      throw error;
    }
  }
);

export const deleteProduct = createAsyncThunk(
  'products/deleteProduct',
  async (id: string, { dispatch, getState }) => {
    try {
      console.log('üóëÔ∏è [REDUX DEBUG] D√©but deleteProduct');
      console.log('üóëÔ∏è [REDUX DEBUG] ID:', id);

      // Utiliser la fonction utilitaire pour g√©rer la suppression offline/online
      const success = await handleOfflineDelete(id);
      
      if (!success) {
        throw new Error('√âchec de la suppression du produit');
      }

      console.log('‚úÖ [REDUX DEBUG] Produit supprim√© avec succ√®s:', id);
      return id;
    } catch (error) {
      console.error('‚ùå [REDUX DEBUG] Erreur deleteProduct:', error);
      throw error;
    }
  }
);

export const searchProducts = createAsyncThunk(
  'products/searchProducts',
  async (query: string, { dispatch }) => {
    try {
      const products = await databaseService.query<Product>(
        `SELECT * FROM products 
         WHERE name LIKE ? OR description LIKE ? OR sku LIKE ?
         ORDER BY name ASC`,
        [`%${query}%`, `%${query}%`, `%${query}%`]
      );
      return products;
    } catch (error) {
      console.error('Erreur searchProducts:', error);
      throw error;
    }
  }
);

export const getProductsByCategory = createAsyncThunk(
  'products/getProductsByCategory',
  async (categoryId: string, { dispatch }) => {
    try {
      const products = await databaseService.query<Product>(
        'SELECT * FROM products WHERE category_id = ? ORDER BY name ASC',
        [categoryId]
      );
      return products;
    } catch (error) {
      console.error('Erreur getProductsByCategory:', error);
      throw error;
    }
  }
);

const productSlice = createSlice({
  name: 'products',
  initialState,
  reducers: {
    setLastSync: (state, action: PayloadAction<string>) => {
      state.lastSync = action.payload;
    },
    setOfflineMode: (state, action: PayloadAction<boolean>) => {
      state.offlineMode = action.payload;
    },
    setSearchQuery: (state, action: PayloadAction<string>) => {
      state.searchQuery = action.payload;
    },
    setSelectedCategory: (state, action: PayloadAction<string>) => {
      state.selectedCategory = action.payload;
    },
    setSortBy: (state, action: PayloadAction<'name' | 'price' | 'created_at'>) => {
      state.sortBy = action.payload;
    },
    setSortOrder: (state, action: PayloadAction<'asc' | 'desc'>) => {
      state.sortOrder = action.payload;
    },
    markProductSynced: (state, action: PayloadAction<string>) => {
      const product = state.products.find(p => p.id === action.payload);
      if (product) {
        product.sync_status = 'synced';
        product.sync_timestamp = new Date().toISOString();
      }
    },
    clearError: (state) => {
      state.error = null;
    },
    resetProducts: (state) => {
      state.products = [];
      state.loading = false;
      state.error = null;
      state.lastSync = null;
      state.offlineMode = false;
    },
  },
  extraReducers: (builder) => {
    builder
      // fetchProducts
      .addCase(fetchProducts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchProducts.fulfilled, (state, action) => {
        state.loading = false;
        state.products = action.payload;
      })
      .addCase(fetchProducts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Erreur de chargement des produits';
      })
      
      // createProduct
      .addCase(createProduct.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createProduct.fulfilled, (state, action) => {
        state.loading = false;
        state.products.push(action.payload);
      })
      .addCase(createProduct.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Erreur lors de la cr√©ation du produit';
      })
      
      // updateProduct
      .addCase(updateProduct.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateProduct.fulfilled, (state, action) => {
        state.loading = false;
        const index = state.products.findIndex(p => p.id === action.payload.id);
        if (index !== -1) {
          state.products[index] = action.payload;
        }
      })
      .addCase(updateProduct.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Erreur lors de la mise √† jour du produit';
      })
      
      // deleteProduct
      .addCase(deleteProduct.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(deleteProduct.fulfilled, (state, action) => {
        state.loading = false;
        state.products = state.products.filter(p => p.id !== action.payload);
      })
      .addCase(deleteProduct.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Erreur lors de la suppression du produit';
      })
      
      // searchProducts
      .addCase(searchProducts.fulfilled, (state, action) => {
        state.products = action.payload;
      })
      
      // getProductsByCategory
      .addCase(getProductsByCategory.fulfilled, (state, action) => {
        state.products = action.payload;
      });
  },
});

export const {
  setLastSync,
  setOfflineMode,
  setSearchQuery,
  setSelectedCategory,
  setSortBy,
  setSortOrder,
  markProductSynced,
  clearError,
  resetProducts,
} = productSlice.actions;

export default productSlice.reducer;
