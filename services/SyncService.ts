import { store } from '../store';
import {
  addSyncError,
  setLastSync,
  setPendingOperations,
  setSyncInProgress
} from '../store/slices/syncSlice';
import { getFirebaseId, isValidFirebaseId } from '../utils/firebaseIdMapper';
import { databaseService, SyncOperation } from './DatabaseService';
import { firebaseService } from './FirebaseService';

interface SyncConfig {
  maxRetries: number;
  retryDelay: number;
  batchSize: number;
  syncInterval: number;
}

class SyncService {
  private config: SyncConfig = {
    maxRetries: 3,
    retryDelay: 5000, // 5 secondes
    batchSize: 10,
    syncInterval: 5 * 60 * 1000, // 5 minutes
  };

  private syncInProgress = false;
  private syncInterval: any = null;
  private isInitialized = false;

  constructor() {
    this.init();
  }

  // Initialiser le service de synchronisation
  async init() {
    if (this.isInitialized) return;

    try {
      // √âcouter les changements de r√©seau
      this.setupNetworkListener();
      
      // D√©marrer la synchronisation p√©riodique
      this.startPeriodicSync();
      
      this.isInitialized = true;
      console.log('üîÑ Service de synchronisation initialis√©');
    } catch (error) {
      console.error('‚ùå Erreur initialisation service de sync:', error);
    }
  }

  // √âcouter les changements de connectivit√©
  private setupNetworkListener() {
    // Pour React Native, on √©coute directement les changements du store Redux
    // au lieu des √©v√©nements DOM
    console.log('üîÑ √âcoute des changements r√©seau configur√©e');
  }

  // D√©marrer la synchronisation p√©riodique
  private startPeriodicSync() {
    this.syncInterval = setInterval(() => {
      const state = store.getState();
      const networkState = state.network as any;
      if (networkState.isConnected && !this.syncInProgress) {
        this.startSync();
      }
    }, this.config.syncInterval);
  }

  // D√©marrer la synchronisation
  async startSync() {
    if (this.syncInProgress) {
      console.log('üîÑ Synchronisation d√©j√† en cours');
      return;
    }

    const state = store.getState();
    const networkState = state.network as any;
    if (!networkState.isConnected) {
      console.log('üåê Pas de connexion - Synchronisation report√©e');
      return;
    }

    this.syncInProgress = true;
    store.dispatch(setSyncInProgress(true));

    console.log('üîÑ D√©marrage de la synchronisation...');

    try {
      // 1. R√©cup√©rer les donn√©es du serveur
      await this.pullFromServer();
      
      // 2. Envoyer les modifications locales
      await this.pushToServer();
      
      // 3. Mettre √† jour le timestamp de derni√®re sync
      await databaseService.updateLastSyncTimestamp();
      store.dispatch(setLastSync(new Date().toISOString()));
      
      console.log('‚úÖ Synchronisation termin√©e avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur de synchronisation:', error);
      store.dispatch(addSyncError(error instanceof Error ? error.message : 'Erreur inconnue'));
    } finally {
      this.syncInProgress = false;
      store.dispatch(setSyncInProgress(false));
    }
  }

  // T√©l√©charger depuis le serveur
  private async pullFromServer() {
    try {
      const lastSync = await databaseService.getLastSyncTimestamp();
      
      console.log('üì• R√©cup√©ration des mises √† jour depuis Firebase...');
      
      // V√©rifier que firebaseService est disponible
      if (!firebaseService) {
        console.log('‚ö†Ô∏è FirebaseService non disponible, synchronisation ignor√©e');
        return;
      }
      
      // R√©cup√©rer les mises √† jour depuis Firebase
      const updates = await firebaseService.getUpdatesSince(lastSync);

      // Appliquer les mises √† jour
      for (const update of updates) {
        await this.applyServerUpdate(update);
      }

      console.log(`üì• ${updates.length} mises √† jour re√ßues de Firebase`);
    } catch (error) {
      console.error('‚ùå Erreur pull:', error);
      throw error;
    }
  }

  // Envoyer vers le serveur
  private async pushToServer() {
    try {
      const pendingOperations = await databaseService.getPendingSyncOperations();
      store.dispatch(setPendingOperations(pendingOperations.length));
      
      if (pendingOperations.length === 0) {
        console.log('üì§ Aucune op√©ration en attente');
        return;
      }

      console.log(`üì§ ${pendingOperations.length} op√©rations en attente`);

      // Trier par priorit√© (1 = haute, 3 = basse)
      pendingOperations.sort((a, b) => a.priority - b.priority);

      // Traiter par batches
      const batches = this.createBatches(pendingOperations, this.config.batchSize);

      for (const batch of batches) {
        await this.processBatch(batch);
      }

      console.log('üì§ Toutes les op√©rations ont √©t√© envoy√©es');
    } catch (error) {
      console.error('‚ùå Erreur push:', error);
      throw error;
    }
  }

  // Cr√©er des batches d'op√©rations
  private createBatches<T>(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  // Traiter un batch d'op√©rations
  private async processBatch(batch: SyncOperation[]) {
    for (const operation of batch) {
      try {
        await this.markOperationAsSyncing(operation.id);
        await this.sendOperationToServer(operation);
        await this.markOperationAsSynced(operation.id);
        
        // Mettre √† jour le store Redux
        this.updateStoreAfterSync(operation);
      } catch (error) {
        await this.handleSyncError(operation, error);
      }
    }
  }

  // Marquer une op√©ration comme en cours de synchronisation
  private async markOperationAsSyncing(operationId: string) {
    await databaseService.update('sync_queue', operationId, {
      status: 'syncing',
    });
  }

  // Marquer une op√©ration comme synchronis√©e
  private async markOperationAsSynced(operationId: string) {
    await databaseService.delete('sync_queue', operationId);
  }

  // Envoyer une op√©ration au serveur
  private async sendOperationToServer(operation: SyncOperation) {
    const { table_name, record_id, operation: op, data } = operation;
    const parsedData = data ? JSON.parse(data) : null;

    // V√©rifier que firebaseService est disponible
    if (!firebaseService) {
      console.log('‚ö†Ô∏è FirebaseService non disponible, op√©ration ignor√©e');
      return;
    }
    
    console.log('üîç [SYNC DEBUG] FirebaseService disponible:', !!firebaseService);
    console.log('üîç [SYNC DEBUG] M√©thode createProduct disponible:', typeof firebaseService.createProduct);

    try {
      console.log(`üì§ Envoi ${op} pour ${table_name}:${record_id}`);
      
      // Traiter selon le type d'op√©ration
      switch (op) {
        case 'create':
          console.log(`üîç [SYNC DEBUG] Op√©ration CREATE pour ${table_name}`);
          if (table_name === 'products') {
            console.log(`üîç [SYNC DEBUG] Cr√©ation produit avec donn√©es:`, parsedData);
            const firebaseId = await firebaseService.createProduct(parsedData);
            console.log(`‚úÖ Produit cr√©√© dans Firebase: ${firebaseId}`);
            // Mettre √† jour le statut local
            await databaseService.update('products', record_id, { 
              sync_status: 'synced',
              firebase_id: firebaseId 
            });
            console.log(`‚úÖ Statut local mis √† jour pour ${record_id}`);
          } else {
            console.log(`‚ö†Ô∏è [SYNC DEBUG] Table non support√©e pour CREATE: ${table_name}`);
          }
          break;
          
            case 'update':
              if (table_name === 'products') {
                // Utiliser l'utilitaire pour obtenir l'ID Firebase
                const firebaseId = await getFirebaseId(record_id);
                
                if (firebaseId) {
                  await firebaseService.updateProduct(firebaseId, parsedData);
                  console.log(`‚úÖ Produit mis √† jour dans Firebase: ${firebaseId}`);
                } else {
                  console.log(`‚ö†Ô∏è Pas de firebase_id trouv√© pour ${record_id}, tentative avec ID local`);
                  await firebaseService.updateProduct(record_id, parsedData);
                  console.log(`‚úÖ Produit mis √† jour dans Firebase: ${record_id}`);
                }
                await databaseService.update('products', record_id, { sync_status: 'synced' });
              }
              break;
          
        case 'delete':
          if (table_name === 'products') {
            // Pour la suppression, v√©rifier si l'ID est un ID Firebase ou local
            if (isValidFirebaseId(record_id)) {
              // C'est un ID Firebase, suppression directe
              await firebaseService.deleteProduct(record_id);
              console.log(`‚úÖ Produit supprim√© de Firebase: ${record_id}`);
            } else {
              // C'est un ID local, chercher l'ID Firebase correspondant
              const firebaseId = await getFirebaseId(record_id);
              if (firebaseId) {
                await firebaseService.deleteProduct(firebaseId);
                console.log(`‚úÖ Produit supprim√© de Firebase avec ID local: ${record_id} -> ${firebaseId}`);
              } else {
                console.log(`‚ö†Ô∏è Aucun ID Firebase trouv√© pour ${record_id}, produit probablement cr√©√© en mode offline uniquement`);
              }
            }
          }
          break;
          
        default:
          console.log(`‚ö†Ô∏è Op√©ration non support√©e: ${op}`);
      }
      
    } catch (error) {
      // Masquer les erreurs "Mode offline" qui sont normales
      if (error instanceof Error && error.message.includes('Mode offline')) {
        console.log(`üì± Mode offline - op√©ration ${op} pour ${table_name}:${record_id} (normal)`);
      } else {
        console.error(`‚ùå Erreur envoi op√©ration ${op} pour ${table_name}:${record_id}:`, error);
      }
      throw error; // Re-lancer pour que la gestion d'erreur parente fonctionne
    }
  }

  // Appliquer une mise √† jour du serveur
  private async applyServerUpdate(update: any) {
    const { table, operation, data } = update;

    switch (operation) {
      case 'create':
      case 'update':
        await databaseService.update(table, data.id, {
          ...data,
          sync_status: 'synced',
          sync_timestamp: new Date().toISOString(),
        });
        break;
      case 'delete':
        await databaseService.delete(table, data.id);
        break;
    }
  }

  // Mettre √† jour le store apr√®s synchronisation
  private updateStoreAfterSync(operation: SyncOperation) {
    const { table_name, record_id } = operation;
    
    // Cette m√©thode sera √©tendue pour mettre √† jour les diff√©rents slices
    // selon le type d'op√©ration et la table concern√©e
    console.log(`‚úÖ Op√©ration ${operation.operation} synchronis√©e pour ${table_name}:${record_id}`);
  }

  // G√©rer les erreurs de synchronisation
  private async handleSyncError(operation: SyncOperation, error: any) {
    const newRetryCount = operation.retry_count + 1;
    
    // Masquer les erreurs "Mode offline" qui sont normales
    const isOfflineError = error instanceof Error && error.message.includes('Mode offline');
    
    if (newRetryCount >= this.config.maxRetries) {
      // Marquer comme erreur d√©finitive
      await databaseService.update('sync_queue', operation.id, {
        status: 'error',
        retry_count: newRetryCount,
        error_message: error.message || 'Erreur inconnue',
      });
      
      if (!isOfflineError) {
        console.error(`‚ùå Erreur d√©finitive pour l'op√©ration ${operation.id}:`, error);
      } else {
        console.log(`üì± Mode offline - erreur d√©finitive pour l'op√©ration ${operation.id} (normal)`);
      }
    } else {
      // Programmer un nouveau retry
      await databaseService.update('sync_queue', operation.id, {
        status: 'pending',
        retry_count: newRetryCount,
        error_message: error.message || 'Erreur inconnue',
      });
      
      if (!isOfflineError) {
        console.log(`‚è≥ Retry ${newRetryCount}/${this.config.maxRetries} pour l'op√©ration ${operation.id}`);
      } else {
        console.log(`üì± Mode offline - retry ${newRetryCount}/${this.config.maxRetries} pour l'op√©ration ${operation.id} (normal)`);
      }
      
      // Programmer le retry avec d√©lai
      setTimeout(() => {
        this.startSync();
      }, this.config.retryDelay);
    }
  }

  // Ajouter une op√©ration √† la queue de synchronisation
  async addToSyncQueue(
    tableName: string,
    recordId: string,
    operation: 'create' | 'update' | 'delete',
    data: any,
    priority: number = 1
  ) {
    try {
      const syncRecord = {
        table_name: tableName,
        record_id: recordId,
        operation,
        data: JSON.stringify(data),
        priority,
        status: 'pending',
        retry_count: 0,
        created_at: new Date().toISOString(),
      };

      await databaseService.insert('sync_queue', syncRecord);

      // Mettre √† jour le compteur d'op√©rations en attente
      const pendingOps = await databaseService.getPendingSyncOperations();
      store.dispatch(setPendingOperations(pendingOps.length));

      console.log(`üìù Op√©ration ${operation} ajout√©e √† la queue pour ${tableName}:${recordId}`);

      // D√©marrer la synchronisation si en ligne
      const state = store.getState();
      const networkState = state.network as any;
      if (networkState.isConnected && !this.syncInProgress) {
        this.startSync();
      }
    } catch (error) {
      console.error('‚ùå Erreur ajout √† la queue de sync:', error);
    }
  }

  // Obtenir le statut de synchronisation
  getSyncStatus() {
    const state = store.getState();
    const syncState = state.sync as any;
    const networkState = state.network as any;
    
    return {
      isOnline: networkState.isConnected,
      syncInProgress: syncState.syncInProgress,
      lastSync: syncState.lastSync,
      pendingOperations: syncState.pendingOperations,
      syncErrors: syncState.syncErrors,
    };
  }

  // Forcer une synchronisation imm√©diate
  async forceSync() {
    console.log('üîÑ Synchronisation forc√©e');
    await this.startSync();
  }

  // Nettoyer les ressources
  destroy() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
    this.isInitialized = false;
    console.log('üîÑ Service de synchronisation d√©truit');
  }
}

// Instance singleton
export const syncService = new SyncService();
