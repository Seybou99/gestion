// Service Firebase r√©el avec Firestore
import {
    addDoc,
    collection,
    deleteDoc,
    doc,
    getDoc,
    getDocs,
    orderBy,
    query,
    serverTimestamp,
    updateDoc,
    where
} from 'firebase/firestore';
import { getFirebaseId, isValidLocalId } from '../utils/firebaseIdMapper';
import { db, FIREBASE_ENABLED, FIREBASE_TIMEOUT, FORCE_OFFLINE_MODE } from './firebase-config';

// Types pour les entit√©s principales
export interface Product {
  id: string;
  name: string;
  description?: string;
  sku: string;
  barcode?: string;
  category_id?: string;
  price_buy: number;
  price_sell: number;
  margin: number;
  unit: string;
  images?: string[];
  is_active: boolean;
  created_at: any;
  updated_at: any;
  sync_status: 'synced' | 'pending' | 'error';
}

export interface Stock {
  id: string;
  product_id: string;
  location_id: string;
  quantity_current: number;
  quantity_min: number;
  quantity_max: number;
  last_movement_date?: any;
  last_movement_type?: string;
  created_at: any;
  updated_at: any;
  sync_status: 'synced' | 'pending' | 'error';
}

export interface Sale {
  id: string;
  customer_id?: string;
  location_id: string;
  total_amount: number;
  tax_amount: number;
  discount_amount: number;
  payment_method: string;
  payment_status: 'paid' | 'pending' | 'refunded';
  sale_date: any;
  created_by: string;
  notes?: string;
  sync_status: 'synced' | 'pending' | 'error';
}

export interface SaleItem {
  id: string;
  sale_id: string;
  product_id: string;
  quantity: number;
  unit_price: number;
  total_price: number;
}

export interface Customer {
  id: string;
  name: string;
  phone?: string;
  email?: string;
  address?: string;
  customer_type: 'retail' | 'wholesale';
  credit_limit: number;
  credit_balance: number;
  created_at: any;
  sync_status: 'synced' | 'pending' | 'error';
}

// Interface pour le service Firebase
export interface FirebaseService {
  init(): Promise<void>;
  // Products
  getProducts(): Promise<Product[]>;
  getProductById(id: string): Promise<Product | null>;
  createProduct(product: Omit<Product, 'id' | 'created_at' | 'updated_at'>): Promise<string>;
  updateProduct(id: string, product: Partial<Product>): Promise<void>;
  deleteProduct(id: string): Promise<void>;
  // Stock
  getStock(): Promise<Stock[]>;
  getStockByProduct(productId: string): Promise<Stock | null>;
  updateStock(id: string, stock: Partial<Stock>): Promise<void>;
  // Sales
  getSales(): Promise<Sale[]>;
  createSale(sale: Omit<Sale, 'id' | 'created_at' | 'updated_at'>): Promise<string>;
  // Customers
  getCustomers(): Promise<Customer[]>;
  createCustomer(customer: Omit<Customer, 'id' | 'created_at'>): Promise<string>;
  // Search
  searchProducts(searchTerm: string): Promise<Product[]>;
  getProductsByCategory(categoryId: string): Promise<Product[]>;
}

class FirebaseServiceImpl implements FirebaseService {
  private isInitialized = false;

  async init(): Promise<void> {
    if (this.isInitialized) return;
    
    try {
      console.log('üî• Service Firebase initialis√© avec Firestore');
      this.isInitialized = true;
    } catch (error) {
      console.error('‚ùå Erreur initialisation Firebase:', error);
      throw error;
    }
  }

  // === PRODUCTS ===
  async getProducts(): Promise<Product[]> {
    try {
      console.log('üî• R√©cup√©ration des produits depuis Firestore avec timeout');
      
      // V√©rifier si Firebase est activ√© ou en mode offline forc√©
      if (!FIREBASE_ENABLED || !db || FORCE_OFFLINE_MODE) {
        console.log(FORCE_OFFLINE_MODE ? 'üì± Mode OFFLINE forc√©' : 'üì± Firebase d√©sactiv√©, retour tableau vide');
        return [];
      }

      // Ajouter un timeout pour √©viter les blocages
      const timeoutPromise = new Promise<Product[]>((_, reject) => {
        setTimeout(() => reject(new Error('Timeout Firebase: getProducts a pris plus de 3 secondes')), FIREBASE_TIMEOUT);
      });
      
      const getProductsPromise = (async () => {
        const productsRef = collection(db, 'products');
        const snapshot = await getDocs(query(productsRef, orderBy('created_at', 'desc')));
        
        const products = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          created_at: doc.data().created_at?.toDate?.()?.toISOString() || doc.data().created_at,
          updated_at: doc.data().updated_at?.toDate?.()?.toISOString() || doc.data().updated_at,
        })) as Product[];
        
        console.log(`üì¶ ${products.length} produits r√©cup√©r√©s depuis Firestore`);
        return products;
      })();
      
      return await Promise.race([getProductsPromise, timeoutPromise]);
    } catch (error) {
      // G√©rer les timeouts silencieusement pour √©viter les erreurs UI
      if (error instanceof Error && error.message.includes('Timeout Firebase')) {
        console.log('‚ö†Ô∏è Firebase timeout (normal en d√©veloppement)');
        return []; // Retourner un tableau vide au lieu de lancer une erreur
      }
      console.error('‚ùå Erreur r√©cup√©ration produits:', error);
      throw error;
    }
  }

  async getProductById(id: string): Promise<Product | null> {
    try {
      const productRef = doc(db, 'products', id);
      const snapshot = await getDoc(productRef);
      
      if (snapshot.exists()) {
        return {
          id: snapshot.id,
          ...snapshot.data(),
          created_at: snapshot.data().created_at?.toDate?.()?.toISOString() || snapshot.data().created_at,
          updated_at: snapshot.data().updated_at?.toDate?.()?.toISOString() || snapshot.data().updated_at,
        } as Product;
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration produit:', error);
      throw error;
    }
  }

  async createProduct(product: Omit<Product, 'id' | 'created_at' | 'updated_at'>): Promise<string> {
    console.log('üöÄ [FIREBASE DEBUG] D√©but createProduct');
    console.log('üöÄ [FIREBASE DEBUG] Product re√ßu:', product);
    
    try {
      console.log('üîÑ [FIREBASE DEBUG] Cr√©ation collection reference');
      const productsRef = collection(db, 'products');
      const now = serverTimestamp();
      
      // Filtrer les valeurs undefined (Firestore ne les accepte pas)
      console.log('üîÑ [FIREBASE DEBUG] Filtrage des valeurs undefined');
      const cleanProduct = Object.fromEntries(
        Object.entries(product).filter(([_, value]) => value !== undefined)
      ) as any;
      console.log('‚úÖ [FIREBASE DEBUG] Product nettoy√©:', cleanProduct);
      
      const productData = {
        ...cleanProduct,
        created_at: now,
        updated_at: now,
        sync_status: 'synced' as const,
      };
      console.log('üì¶ [FIREBASE DEBUG] ProductData final:', productData);
      
      console.log('üîÑ [FIREBASE DEBUG] Appel addDoc avec timeout');
      
      // V√©rifier si Firebase est activ√© ou en mode offline forc√©
      if (!FIREBASE_ENABLED || !db || FORCE_OFFLINE_MODE) {
        console.log(FORCE_OFFLINE_MODE ? 'üì± Mode OFFLINE forc√©, cr√©ation locale uniquement' : 'üì± Firebase d√©sactiv√©, cr√©ation locale uniquement');
        throw new Error(FORCE_OFFLINE_MODE ? 'Mode offline' : 'Firebase d√©sactiv√©');
      }

      // Ajouter un timeout pour √©viter les blocages
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Timeout Firebase: addDoc a pris plus de 3 secondes')), FIREBASE_TIMEOUT);
      });
      
      const addDocPromise = addDoc(productsRef, productData);
      
      const docRef = await Promise.race([addDocPromise, timeoutPromise]) as any;
      console.log('‚úÖ [FIREBASE DEBUG] addDoc termin√©, ID:', docRef.id);
      
      console.log('‚úÖ [FIREBASE DEBUG] Produit cr√©√© dans Firestore:', docRef.id);
      return docRef.id;
    } catch (error) {
      // G√©rer les timeouts et mode offline silencieusement
      if (error instanceof Error && error.message.includes('Timeout Firebase')) {
        console.log('‚ö†Ô∏è Firebase timeout cr√©ation produit (normal en d√©veloppement)');
        throw new Error('Firebase temporairement indisponible');
      }
      
      // G√©rer le mode offline silencieusement
      if (error instanceof Error && error.message.includes('Mode offline')) {
        console.log('üì± Mode offline - cr√©ation locale uniquement (normal)');
        throw new Error('Mode offline');
      }
      
      console.error('‚ùå [FIREBASE DEBUG] Erreur cr√©ation produit:', error);
      console.error('‚ùå [FIREBASE DEBUG] Stack trace:', error instanceof Error ? error.stack : 'No stack');
      throw error;
    }
  }

  async updateProduct(id: string, updates: Partial<Product>): Promise<void> {
    try {
      console.log('üîÑ [FIREBASE DEBUG] D√©but updateProduct');
      console.log('üîÑ [FIREBASE DEBUG] ID re√ßu:', id);
      console.log('üîÑ [FIREBASE DEBUG] Updates re√ßus:', updates);

      // V√©rifier si Firebase est activ√© ou en mode offline forc√©
      if (!FIREBASE_ENABLED || !db || FORCE_OFFLINE_MODE) {
        console.log(FORCE_OFFLINE_MODE ? 'üì± Mode OFFLINE forc√©, mise √† jour locale uniquement' : 'üì± Firebase d√©sactiv√©, mise √† jour locale uniquement');
        throw new Error(FORCE_OFFLINE_MODE ? 'Mode offline' : 'Firebase d√©sactiv√©');
      }

      // D√©terminer l'ID Firebase √† utiliser
      let firebaseId = id;
      
      // Si l'ID re√ßu est un ID local, chercher l'ID Firebase correspondant
      if (isValidLocalId(id)) {
        console.log('üîÑ [FIREBASE DEBUG] ID local d√©tect√©, recherche Firebase ID...');
        const foundFirebaseId = await getFirebaseId(id);
        if (foundFirebaseId) {
          firebaseId = foundFirebaseId;
          console.log('‚úÖ [FIREBASE DEBUG] Firebase ID trouv√©:', firebaseId);
        } else {
          console.log('‚ö†Ô∏è [FIREBASE DEBUG] Aucun Firebase ID trouv√©, utilisation ID local');
        }
      } else if ((updates as any).firebase_id) {
        firebaseId = (updates as any).firebase_id;
        console.log('üîÑ [FIREBASE DEBUG] Utilisation firebase_id des updates:', firebaseId);
      } else {
        console.log('üîÑ [FIREBASE DEBUG] Utilisation ID direct:', firebaseId);
      }

      console.log('üîÑ [FIREBASE DEBUG] Cr√©ation document reference avec ID:', firebaseId);
      const productRef = doc(db, 'products', firebaseId);
      
      // Filtrer les valeurs undefined (Firestore ne les accepte pas)
      const cleanUpdates = Object.fromEntries(
        Object.entries(updates).filter(([_, value]) => value !== undefined)
      ) as any;

      const updateData = {
        ...cleanUpdates,
        updated_at: serverTimestamp(),
        sync_status: 'synced',
      };

      console.log('‚úÖ [FIREBASE DEBUG] UpdateData final:', updateData);
      console.log('üîÑ [FIREBASE DEBUG] Appel updateDoc avec timeout');
      
      // Utiliser Promise.race pour timeout
      await Promise.race([
        updateDoc(productRef, updateData),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout Firebase: updateProduct a pris plus de 3 secondes')), FIREBASE_TIMEOUT)
        )
      ]);

      console.log('‚úÖ [FIREBASE DEBUG] updateDoc termin√©');
      console.log('‚úÖ [FIREBASE DEBUG] Produit mis √† jour dans Firestore:', id);
    } catch (error) {
      // G√©rer les timeouts et mode offline silencieusement
      if (error instanceof Error && error.message.includes('Timeout Firebase')) {
        console.log('‚ö†Ô∏è Firebase timeout mise √† jour produit (normal en d√©veloppement)');
        throw new Error('Firebase temporairement indisponible');
      }
      // G√©rer le mode offline silencieusement
      if (error instanceof Error && error.message.includes('Mode offline')) {
        console.log('üì± Mode offline - mise √† jour locale uniquement (normal)');
        throw new Error('Mode offline');
      }
      console.error('‚ùå [FIREBASE DEBUG] Erreur mise √† jour produit:', error);
      console.error('‚ùå [FIREBASE DEBUG] Stack trace:', error instanceof Error ? error.stack : 'No stack');
      throw error;
    }
  }

  async deleteProduct(id: string): Promise<void> {
    try {
      console.log('üóëÔ∏è [FIREBASE DEBUG] D√©but deleteProduct');
      console.log('üóëÔ∏è [FIREBASE DEBUG] ID re√ßu:', id);

      // V√©rifier si Firebase est activ√© ou en mode offline forc√©
      if (!FIREBASE_ENABLED || !db || FORCE_OFFLINE_MODE) {
        console.log(FORCE_OFFLINE_MODE ? 'üì± Mode OFFLINE forc√©, suppression locale uniquement' : 'üì± Firebase d√©sactiv√©, suppression locale uniquement');
        throw new Error(FORCE_OFFLINE_MODE ? 'Mode offline' : 'Firebase d√©sactiv√©');
      }

      // D√©terminer l'ID Firebase √† utiliser pour la suppression
      let firebaseId = id;
      
      // Si l'ID re√ßu est un ID local, chercher l'ID Firebase correspondant
      if (isValidLocalId(id)) {
        console.log('üîÑ [FIREBASE DEBUG] ID local d√©tect√©, recherche Firebase ID...');
        const foundFirebaseId = await getFirebaseId(id);
        if (foundFirebaseId) {
          firebaseId = foundFirebaseId;
          console.log('‚úÖ [FIREBASE DEBUG] Firebase ID trouv√©:', firebaseId);
        } else {
          console.log('‚ö†Ô∏è [FIREBASE DEBUG] Aucun Firebase ID trouv√©, utilisation ID local');
        }
      } else {
        console.log('üîÑ [FIREBASE DEBUG] ID Firebase direct:', firebaseId);
      }

      console.log('üóëÔ∏è [FIREBASE DEBUG] Cr√©ation document reference avec ID:', firebaseId);
      const productRef = doc(db, 'products', firebaseId);

      console.log('üóëÔ∏è [FIREBASE DEBUG] Appel deleteDoc avec timeout');
      
      // Utiliser Promise.race pour timeout
      await Promise.race([
        deleteDoc(productRef),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Timeout Firebase: deleteProduct a pris plus de 3 secondes')), FIREBASE_TIMEOUT)
        )
      ]);

      console.log('‚úÖ [FIREBASE DEBUG] deleteDoc termin√©');
      console.log('‚úÖ [FIREBASE DEBUG] Produit supprim√© de Firestore:', id);
    } catch (error) {
      // G√©rer les timeouts et mode offline silencieusement
      if (error instanceof Error && error.message.includes('Timeout Firebase')) {
        console.log('‚ö†Ô∏è Firebase timeout suppression produit (normal en d√©veloppement)');
        throw new Error('Firebase temporairement indisponible');
      }
      // G√©rer le mode offline silencieusement
      if (error instanceof Error && error.message.includes('Mode offline')) {
        console.log('üì± Mode offline - suppression locale uniquement (normal)');
        throw new Error('Mode offline');
      }
      console.error('‚ùå [FIREBASE DEBUG] Erreur suppression produit:', error);
      console.error('‚ùå [FIREBASE DEBUG] Stack trace:', error instanceof Error ? error.stack : 'No stack');
      throw error;
    }
  }

  // === STOCK ===
  async getStock(): Promise<Stock[]> {
    try {
      console.log('üî• R√©cup√©ration du stock depuis Firestore');
      const stockRef = collection(db, 'stock');
      const snapshot = await getDocs(stockRef);
      
      const stock = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        created_at: doc.data().created_at?.toDate?.()?.toISOString() || doc.data().created_at,
        updated_at: doc.data().updated_at?.toDate?.()?.toISOString() || doc.data().updated_at,
      })) as Stock[];
      
      console.log(`üìä ${stock.length} entr√©es de stock r√©cup√©r√©es`);
      return stock;
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration stock:', error);
      throw error;
    }
  }

  async getStockByProduct(productId: string): Promise<Stock | null> {
    try {
      const stockRef = collection(db, 'stock');
      const q = query(stockRef, where('product_id', '==', productId));
      const snapshot = await getDocs(q);
      
      if (!snapshot.empty) {
        const doc = snapshot.docs[0];
        return {
          id: doc.id,
          ...doc.data(),
          created_at: doc.data().created_at?.toDate?.()?.toISOString() || doc.data().created_at,
          updated_at: doc.data().updated_at?.toDate?.()?.toISOString() || doc.data().updated_at,
        } as Stock;
      }
      
      return null;
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration stock par produit:', error);
      throw error;
    }
  }

  async updateStock(id: string, updates: Partial<Stock>): Promise<void> {
    try {
      const stockRef = doc(db, 'stock', id);
      await updateDoc(stockRef, {
        ...updates,
        updated_at: serverTimestamp(),
      });
      console.log('‚úÖ Stock mis √† jour dans Firestore:', id);
    } catch (error) {
      console.error('‚ùå Erreur mise √† jour stock:', error);
      throw error;
    }
  }

  // === SALES ===
  async getSales(): Promise<Sale[]> {
    try {
      console.log('üî• R√©cup√©ration des ventes depuis Firestore');
      const salesRef = collection(db, 'sales');
      const snapshot = await getDocs(query(salesRef, orderBy('sale_date', 'desc')));
      
      const sales = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        created_at: doc.data().created_at?.toDate?.()?.toISOString() || doc.data().created_at,
        updated_at: doc.data().updated_at?.toDate?.()?.toISOString() || doc.data().updated_at,
      })) as unknown as Sale[];
      
      console.log(`üí∞ ${sales.length} ventes r√©cup√©r√©es`);
      return sales;
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration ventes:', error);
      throw error;
    }
  }

  async createSale(sale: Omit<Sale, 'id' | 'created_at' | 'updated_at'>): Promise<string> {
    try {
      const salesRef = collection(db, 'sales');
      const now = serverTimestamp();
      
      const saleData = {
        ...sale,
        created_at: now,
        updated_at: now,
        sync_status: 'synced' as const,
      };
      
      const docRef = await addDoc(salesRef, saleData);
      console.log('‚úÖ Vente cr√©√©e dans Firestore:', docRef.id);
      return docRef.id;
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation vente:', error);
      throw error;
    }
  }

  // === CUSTOMERS ===
  async getCustomers(): Promise<Customer[]> {
    try {
      console.log('üî• R√©cup√©ration des clients depuis Firestore');
      const customersRef = collection(db, 'customers');
      const snapshot = await getDocs(query(customersRef, orderBy('created_at', 'desc')));
      
      const customers = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        created_at: doc.data().created_at?.toDate?.()?.toISOString() || doc.data().created_at,
      })) as Customer[];
      
      console.log(`üë• ${customers.length} clients r√©cup√©r√©s`);
      return customers;
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration clients:', error);
      throw error;
    }
  }

  async createCustomer(customer: Omit<Customer, 'id' | 'created_at'>): Promise<string> {
    try {
      const customersRef = collection(db, 'customers');
      const now = serverTimestamp();
      
      const customerData = {
        ...customer,
        created_at: now,
        sync_status: 'synced' as const,
      };
      
      const docRef = await addDoc(customersRef, customerData);
      console.log('‚úÖ Client cr√©√© dans Firestore:', docRef.id);
      return docRef.id;
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation client:', error);
      throw error;
    }
  }

  // === SEARCH ===
  async searchProducts(searchTerm: string): Promise<Product[]> {
    try {
      const products = await this.getProducts();
      return products.filter(product => 
        product.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        product.sku.toLowerCase().includes(searchTerm.toLowerCase()) ||
        (product.description && product.description.toLowerCase().includes(searchTerm.toLowerCase()))
      );
    } catch (error) {
      console.error('‚ùå Erreur recherche produits:', error);
      throw error;
    }
  }

  async getProductsByCategory(categoryId: string): Promise<Product[]> {
    try {
      const productsRef = collection(db, 'products');
      const q = query(productsRef, where('category_id', '==', categoryId));
      const snapshot = await getDocs(q);
      
      return snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        created_at: doc.data().created_at?.toDate?.()?.toISOString() || doc.data().created_at,
        updated_at: doc.data().updated_at?.toDate?.()?.toISOString() || doc.data().updated_at,
      })) as Product[];
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration produits par cat√©gorie:', error);
      throw error;
    }
  }

  // === SYNC ===
  async getUpdatesSince(timestamp: string): Promise<any[]> {
    try {
      console.log(`üîç R√©cup√©ration des mises √† jour depuis Firestore depuis ${timestamp}`);
      // Impl√©mentation pour r√©cup√©rer les mises √† jour depuis une date
      return [];
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration mises √† jour:', error);
      throw error;
    }
  }

  async checkConnectivity(): Promise<boolean> {
    try {
      // Test simple de connectivit√©
      await getDocs(collection(db, 'products'));
      console.log('‚úÖ Connectivit√© Firebase v√©rifi√©e');
      return true;
    } catch (error) {
      console.error('‚ùå Erreur connectivit√© Firebase:', error);
      return false;
    }
  }
}

export const firebaseService = new FirebaseServiceImpl();